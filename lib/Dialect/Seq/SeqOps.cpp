//===- SeqOps.cpp - Implement the Seq operations ------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements sequential ops.
//
//===----------------------------------------------------------------------===//

#include "circt/Dialect/Seq/SeqOps.h"
#include "circt/Dialect/SV/SVOps.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/Diagnostics.h"
#include "mlir/IR/DialectImplementation.h"
#include "mlir/Support/LogicalResult.h"
#include <initializer_list>

using namespace mlir;
using namespace circt;
using namespace seq;

//===----------------------------------------------------------------------===//
// CompReg parsing & printing logic
//===----------------------------------------------------------------------===//

ParseResult parseCompRegOp(OpAsmParser &parser, OperationState &result) {
  llvm::SMLoc loc = parser.getCurrentLocation();
  SmallVector<OpAsmParser::OperandType, 4> operands;
  if (parser.parseOperandList(operands))
    return failure();
  switch (operands.size()) {
  case 0:
    return parser.emitError(loc, "expected operands");
  case 1:
    return parser.emitError(loc, "expected clock operand");
  case 2:
    // No reset.
    break;
  case 3:
    return parser.emitError(loc, "expected resetValue operand");
  case 4:
    // reset and reset value included.
    break;
  default:
    return parser.emitError(loc, "too many operands");
  }

  Type ty;
  if (parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
      parser.parseType(ty))
    return failure();
  Type i1 = IntegerType::get(result.getContext(), 1);

  result.addTypes({ty});
  if (operands.size() == 2)
    return parser.resolveOperands(operands, {ty, i1}, loc, result.operands);
  else
    return parser.resolveOperands(operands, {ty, i1, i1, ty}, loc,
                                  result.operands);
}

static void printCompRegOp(::mlir::OpAsmPrinter &p, CompRegOp reg) {
  p << "seq.compreg";
  p << ' ' << reg.input() << ", " << reg.clk();
  if (reg.reset()) {
    p << ", " << reg.reset() << ", " << reg.resetValue() << ' ';
  }
  p.printOptionalAttrDict(reg->getAttrs(), /*elidedAttrs=*/{});
  p << " : " << reg.input().getType();
}

static LogicalResult verifyReg(RegOp reg) {
  switch (reg.resetType()) {
  case ::ResetType::SyncReset:
  case ::ResetType::AsyncReset: {
    if (!(reg.reset() && reg.resetValue() && reg.resetEdge())) {
      return reg.emitOpError(
          "reset and resetValue operands, and resetEdge attributes must be set "
          "when resetType is SyncReset or AsyncReset");
    }
    auto inputType = reg.input().getType();
    auto resetValueType = reg.resetValue().getType();
    if (inputType != resetValueType) {
      return reg.emitOpError(
                 "resetValue's type, when specified, must match those of input")
             << "resetValueType = " << resetValueType
             << ", inputType = " << inputType;
    }
    break;
  }

  case ::ResetType::NoReset:
    if (reg.reset() || reg.resetValue() || reg.resetEdge()) {
      return reg.emitOpError(
          "reset and resetValue operands, and resetEdge attributes must not be "
          "set when resetType is NoReset");
    }
    break;
  }
  return success();
}

//===----------------------------------------------------------------------===//
// TableGen generated logic.
//===----------------------------------------------------------------------===//

// Provide the autogenerated implementation guts for the Op classes.
#define GET_OP_CLASSES
#include "circt/Dialect/Seq/Seq.cpp.inc"
